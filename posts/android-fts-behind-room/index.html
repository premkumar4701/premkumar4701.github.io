<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes | Prem Kumar J</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
I am starting with a question here, Has a android dev I used the FTS(Full Text Search) with room but ever thought about how it works behind the scenes ? What If suddenly another library takes over the room then we don&rsquo;t know how to implement FTS it feels so bad right ? Exactly I felt the same the underling SQLite have not changed only the top layer changed which breaks our entire work flow. Nope I don&rsquo;t want to allow that. So, I decide to go behind the room FTS annotation and How SQLite actually implements the FTS. So, We can make are foundation strong enough If the top layer drops still ok I can implemented the feature which gives more control and confidence. Let&rsquo;s deep dive into it now.">
<meta name="author" content="">
<link rel="canonical" href="https://premkumar4701.github.io/posts/android-fts-behind-room/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6917c33f752d2902fcce2943406f60cb76591197ba6ecc2dbfb6451ea7fa304e.css" integrity="sha256-aRfDP3UtKQL8zilDQG9gy3ZZEZe6bswtv7ZFHqf6ME4=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://premkumar4701.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://premkumar4701.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://premkumar4701.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://premkumar4701.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://premkumar4701.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://premkumar4701.github.io/posts/android-fts-behind-room/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://premkumar4701.github.io/posts/android-fts-behind-room/">
  <meta property="og:site_name" content="Prem Kumar J">
  <meta property="og:title" content="Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes">
  <meta property="og:description" content="Introduction I am starting with a question here, Has a android dev I used the FTS(Full Text Search) with room but ever thought about how it works behind the scenes ? What If suddenly another library takes over the room then we don’t know how to implement FTS it feels so bad right ? Exactly I felt the same the underling SQLite have not changed only the top layer changed which breaks our entire work flow. Nope I don’t want to allow that. So, I decide to go behind the room FTS annotation and How SQLite actually implements the FTS. So, We can make are foundation strong enough If the top layer drops still ok I can implemented the feature which gives more control and confidence. Let’s deep dive into it now.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-28T09:42:36+05:30">
    <meta property="article:modified_time" content="2025-12-28T09:42:36+05:30">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes">
<meta name="twitter:description" content="Introduction
I am starting with a question here, Has a android dev I used the FTS(Full Text Search) with room but ever thought about how it works behind the scenes ? What If suddenly another library takes over the room then we don&rsquo;t know how to implement FTS it feels so bad right ? Exactly I felt the same the underling SQLite have not changed only the top layer changed which breaks our entire work flow. Nope I don&rsquo;t want to allow that. So, I decide to go behind the room FTS annotation and How SQLite actually implements the FTS. So, We can make are foundation strong enough If the top layer drops still ok I can implemented the feature which gives more control and confidence. Let&rsquo;s deep dive into it now.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://premkumar4701.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes",
      "item": "https://premkumar4701.github.io/posts/android-fts-behind-room/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes",
  "name": "Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes",
  "description": "Introduction I am starting with a question here, Has a android dev I used the FTS(Full Text Search) with room but ever thought about how it works behind the scenes ? What If suddenly another library takes over the room then we don\u0026rsquo;t know how to implement FTS it feels so bad right ? Exactly I felt the same the underling SQLite have not changed only the top layer changed which breaks our entire work flow. Nope I don\u0026rsquo;t want to allow that. So, I decide to go behind the room FTS annotation and How SQLite actually implements the FTS. So, We can make are foundation strong enough If the top layer drops still ok I can implemented the feature which gives more control and confidence. Let\u0026rsquo;s deep dive into it now.\n",
  "keywords": [
    
  ],
  "articleBody": "Introduction I am starting with a question here, Has a android dev I used the FTS(Full Text Search) with room but ever thought about how it works behind the scenes ? What If suddenly another library takes over the room then we don’t know how to implement FTS it feels so bad right ? Exactly I felt the same the underling SQLite have not changed only the top layer changed which breaks our entire work flow. Nope I don’t want to allow that. So, I decide to go behind the room FTS annotation and How SQLite actually implements the FTS. So, We can make are foundation strong enough If the top layer drops still ok I can implemented the feature which gives more control and confidence. Let’s deep dive into it now.\nNOTE: This blog is based on SQLite3 and Fts4\nRoom FTS First comes how the room setup will look for the FTS.\n@Entity(tableName = \"locations_search_fts\") @Fts4(contentEntity = LocationEntity::class, tokenizer = FtsOptions.TOKENIZER_PORTER) data class LocationSearchFTSEntity( @ColumnInfo(name = \"name\") val name: String ) Create a new fts search entity with the required fields which is used in your search query. The @Fts4 tells room to generate the necessary tables for the FTS. It also takes some parameters which are\nFts4(\r@NonNull String tokenizer,\r@NonNull String[] tokenizerArgs,\r@NonNull KClass\u003c@NonNull ?\u003e contentEntity,\r@NonNull String languageId,\r@NonNull FtsOptions.MatchInfo matchInfo,\r@NonNull String[] notIndexed,\r@NonNull int[] prefix,\r@NonNull FtsOptions.Order order\r) Tokenizer: There are 3 type of tokenizer which are SIMPLE(Default), PORTER, UNICODE61. We can choose this based on the applciation needs For Example: The location searching for is Chennai is my favourite place. The user entered Chennae When using SIMPLE tokenizer it will not return the data which means it can’t match with the actual data. But in PORTER tokenizer uses the Porter Stemming algorithm which makes things easier this will return the excepted result. For more details why this happens you can refer here https://www.sqlite.org/fts3.html#tokenizer.\nContentEntity: The Original Entity all write operations has to be done in original table the room will handle the XFts table to map with the original entity by triggers whenever the insert or update or any write operation done in original table room automatically triggers inbuild fun to keep the FTS table UpToDate.\nFor other parameters checkout: https://developer.android.com/reference/androidx/room/Fts4#public-constructors_1\nRelating Room Setup to Plain SQLite @FTS4 it will trigger methods which is responsible to create a virtual table underneath.\nCREATE VIRTUAL TABLE locations_search_fts USING fts4(name); The above query by default uses the SIMPLE Tokenizer. To tell the SQLite to use the PORTER then the query will look like this\nCREATE VIRTUAL TABLE locations_search_fts USING fts4(name, tokenize=porter); ContentEntity has told before this will create triggers. So, that we does not need to manually keep the tables in sync. This means that in order to keep an FTS in sync with an content table, any INSERT or UPDATE or DELETE operations must be applied first to the FTS table, and then to the content table. For example:\nCREATE TRIGGER locations_bd BEFORE DELETE ON locations BEGIN\rDELETE FROM locations_search_fts WHERE docid=old.rowid;\rEND;\rCREATE TRIGGER locations_au AFTER UPDATE ON locations BEGIN\rINSERT INTO location_search_fts(docid, name) VALUES(new.rowid, new.name);\rEND;\rCREATE TRIGGER locations_ai AFTER INSERT ON locations BEGIN\rINSERT INTO location_search_fts(docid, name) VALUES(new.rowid, new.name);\rEND; Full Text Index Queries The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form “ MATCH ” as part of the WHERE clause of a SELECT statement that reads data from an FTS table.\nThe examples in this block assume the following FTS table:\nCREATE VIRTUAL TABLE locations_fts USING fts3(name, pincode); How to query FTS effectively:\nSELECT * FROM locations_fts WHERE rowid = 15; -- This rowid is the primary key which by default the fts table will have.\rSELECT * FROM locations_fts WHERE name MATCH 'chennai'; -- Match with name.\rSELECT * FROM locations_fts WHERE pincode MATCH '6008'; -- Match with pincode.\rSELECT * FROM locations_fts WHERE rowid BETWEEN 15 AND 20; -- Fast. Rowid lookup.\rSELECT * FROM locations_fts WHERE locations_fts MATCH '600118'; -- Match with name or pincode How not to use:\nSELECT * FROM mail WHERE subject = 'database'; -- Slow. Linear scan. FTS tables support three basic query types:\nToken or token prefix queries. Phrase queries. NEAR queries. There we will take a close look into first 2 types which is most commonly used.\n1. Token or token prefix queries: It search for the specific term in the table mentioned column or that contain a term with a specified prefix. The query expression used to search for a term prefix is the prefix itself with a ‘*’ character appended to it. For example:\n-- Query for all locations containing the term \"delhi\"\rSELECT * FROM locations WHERE locations MATCH 'delhi';\r-- Query for all locations containing a term with the prefix \"del\".\r-- This will match \"delhi\", \"delta\", \"delivery\", etc.\rSELECT * FROM locations WHERE locations MATCH 'del*'; 2. Phrase queries: Phrase queries are specified by enclosing a space separated sequence of terms or term prefixes in double quotes (\"). For example:\n-- Query for all locations that contain the phrase \"central park\"\rSELECT * FROM locations WHERE locations MATCH '\"central park\"';\r-- Query for all locations that contain a phrase matching \"cen* par*\".\r-- This can match \"central park\", \"century parade\", \"census part\", etc.\rSELECT * FROM locations WHERE locations MATCH '\"cen* par*\"'; How the Queries Work:\nMATCH ‘“central park”’ returns only the loactions with the exact phrase “central park”. MATCH ‘“cen* par*”’ returns any lcoations where words starting with “cen” are immediately followed by words starting with “par”, such as:\n“Central Park”, “Century Parade”, “Census Part”\nFor more refer here: https://www.sqlite.org/fts3.html#full_text_index_queries\nWhy to use this? Why can’t just use the LIKE operator in query?\nAnswer: Wait for the 2 part.\nHappy coding.\n",
  "wordCount" : "979",
  "inLanguage": "en",
  "datePublished": "2025-12-28T09:42:36+05:30",
  "dateModified": "2025-12-28T09:42:36+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://premkumar4701.github.io/posts/android-fts-behind-room/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Prem Kumar J",
    "logo": {
      "@type": "ImageObject",
      "url": "https://premkumar4701.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://premkumar4701.github.io/" accesskey="h" title="Prem Kumar J (Alt + H)">Prem Kumar J</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Room FTS Made Simple: What Really Happens in SQLite Behind the Scenes
    </h1>
    <div class="post-meta"><span title='2025-12-28 09:42:36 +0530 IST'>December 28, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>I am starting with a question here, Has a android dev I used the FTS(Full Text Search) with room but ever thought about how it works behind the scenes ? What If suddenly another library takes over the room then we don&rsquo;t know how to implement FTS it feels so bad right ? Exactly I felt the same the underling SQLite have not changed only the top layer changed which breaks our entire work flow. Nope I don&rsquo;t want to allow that. So, I decide to go behind the room FTS annotation and How SQLite actually implements the FTS. So, We can make are foundation strong enough If the top layer drops still ok I can implemented the feature which gives more control and confidence. Let&rsquo;s deep dive into it now.</p>
<p><em><strong>NOTE: This blog is based on SQLite3 and Fts4</strong></em></p>
<h2 id="room-fts">Room FTS<a hidden class="anchor" aria-hidden="true" href="#room-fts">#</a></h2>
<p>First comes how the room setup will look for the FTS.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Kotlin" data-lang="Kotlin"><span style="display:flex;"><span><span style="color:#a6e22e">@Entity</span>(tableName = <span style="color:#e6db74">&#34;locations_search_fts&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Fts4</span>(contentEntity = LocationEntity<span style="color:#f92672">::</span><span style="color:#66d9ef">class</span>, tokenizer = <span style="color:#a6e22e">FtsOptions</span>.TOKENIZER_PORTER)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LocationSearchFTSEntity</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@ColumnInfo</span>(name = <span style="color:#e6db74">&#34;name&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> name: String
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><p>Create a new fts search entity with the required fields which is used in your search query.
The <strong>@Fts4</strong> tells room to generate the necessary tables for the FTS. It also takes some parameters which are</p>
<pre tabindex="0"><code>Fts4(
    @NonNull String tokenizer,
    @NonNull String[] tokenizerArgs,
    @NonNull KClass&lt;@NonNull ?&gt; contentEntity,
    @NonNull String languageId,
    @NonNull FtsOptions.MatchInfo matchInfo,
    @NonNull String[] notIndexed,
    @NonNull int[] prefix,
    @NonNull FtsOptions.Order order
)
</code></pre><p><strong>Tokenizer</strong>:
There are 3 type of tokenizer which are SIMPLE(Default), PORTER, UNICODE61.
We can choose this based on the applciation needs
For Example:
The location searching for is <code>Chennai is my favourite place</code>.
The user entered <code>Chennae</code>
When using <em>SIMPLE</em>  tokenizer it will not return the data which means it can&rsquo;t match with the actual data. But in <em>PORTER</em> tokenizer uses the <em>Porter Stemming algorithm</em> which makes things easier this will return the excepted result. For more details why this happens you can refer here <a href="https://www.sqlite.org/fts3.html#tokenizer">https://www.sqlite.org/fts3.html#tokenizer</a>.</p>
<p><strong>ContentEntity</strong>:
The Original Entity all write operations has to be done in original table the room will handle the <em>XFts</em> table to map with the original entity by triggers whenever the insert or update or any write operation done in original table room automatically triggers inbuild fun to keep the <em>FTS</em> table UpToDate.</p>
<p>For other parameters checkout: <a href="https://developer.android.com/reference/androidx/room/Fts4#public-constructors_1">https://developer.android.com/reference/androidx/room/Fts4#public-constructors_1</a></p>
<h2 id="relating-room-setup-to-plain-sqlite">Relating Room Setup to Plain SQLite<a hidden class="anchor" aria-hidden="true" href="#relating-room-setup-to-plain-sqlite">#</a></h2>
<p><strong>@FTS4</strong> it will trigger methods which is responsible to create a virtual table underneath.</p>
<pre tabindex="0"><code class="language-SQLite" data-lang="SQLite">CREATE VIRTUAL TABLE locations_search_fts USING fts4(name);
</code></pre><p>The above query by default uses the <em>SIMPLE</em> Tokenizer. To tell the SQLite to use the <em>PORTER</em> then the query will look like this</p>
<pre tabindex="0"><code class="language-SQLite" data-lang="SQLite">CREATE VIRTUAL TABLE locations_search_fts USING fts4(name, tokenize=porter);
</code></pre><p><strong>ContentEntity</strong> has told before this will create triggers. So, that we does not need to manually keep the tables in sync.
This means that in order to keep an FTS in sync with an content table, any INSERT or UPDATE or DELETE operations must be applied first to the FTS table, and then to the  content table.
For example:</p>
<pre tabindex="0"><code class="language-SQLite" data-lang="SQLite">CREATE TRIGGER locations_bd BEFORE DELETE ON locations BEGIN
  DELETE FROM locations_search_fts WHERE docid=old.rowid;
END;

CREATE TRIGGER locations_au AFTER UPDATE ON locations BEGIN
  INSERT INTO location_search_fts(docid, name) VALUES(new.rowid, new.name);
END;

CREATE TRIGGER locations_ai AFTER INSERT ON locations BEGIN
  INSERT INTO location_search_fts(docid, name) VALUES(new.rowid, new.name);
END;
</code></pre><p><strong>Full Text Index Queries</strong> The most useful thing about FTS tables is the queries that may be performed using the built-in full-text index. Full-text queries are performed by specifying a clause of the form &ldquo;<!-- raw HTML omitted --> MATCH <!-- raw HTML omitted -->&rdquo; as part of the WHERE clause of a SELECT statement that reads data from an FTS table.</p>
<p>The examples in this block assume the following FTS table:</p>
<pre tabindex="0"><code>CREATE VIRTUAL TABLE locations_fts USING fts3(name, pincode);
</code></pre><p>How to query FTS effectively:</p>
<pre tabindex="0"><code>SELECT * FROM locations_fts WHERE rowid = 15;                -- This rowid is the primary key which by default the fts table will have.
SELECT * FROM locations_fts WHERE name MATCH &#39;chennai&#39;;       -- Match with name.
SELECT * FROM locations_fts WHERE pincode MATCH &#39;6008&#39;;       -- Match with pincode.
SELECT * FROM locations_fts WHERE rowid BETWEEN 15 AND 20;   -- Fast. Rowid lookup.
SELECT * FROM locations_fts WHERE locations_fts MATCH &#39;600118&#39;;  -- Match with name or pincode
</code></pre><p>How not to use:</p>
<pre tabindex="0"><code>SELECT * FROM mail WHERE subject = &#39;database&#39;;      -- Slow. Linear scan.
</code></pre><p>FTS tables support three basic query types:</p>
<ul>
<li>Token or token prefix queries.</li>
<li>Phrase queries.</li>
<li>NEAR queries.</li>
</ul>
<p><em><strong>There we will take a close look into first 2 types which is most commonly used.</strong></em></p>
<p><strong>1. Token or token prefix queries:</strong> It search for the specific term in the table mentioned column or that contain a term with a specified prefix. The query expression used to search for a term prefix is the prefix itself with a &lsquo;*&rsquo; character appended to it. For example:</p>
<pre tabindex="0"><code>-- Query for all locations containing the term &#34;delhi&#34;
SELECT * FROM locations WHERE locations MATCH &#39;delhi&#39;;

-- Query for all locations containing a term with the prefix &#34;del&#34;.
-- This will match &#34;delhi&#34;, &#34;delta&#34;, &#34;delivery&#34;, etc.
SELECT * FROM locations WHERE locations MATCH &#39;del*&#39;;
</code></pre><p><strong>2. Phrase queries:</strong> Phrase queries are specified by enclosing a space separated sequence of terms or term prefixes in double quotes (&quot;). For example:</p>
<pre tabindex="0"><code>-- Query for all locations that contain the phrase &#34;central park&#34;
SELECT * FROM locations WHERE locations MATCH &#39;&#34;central park&#34;&#39;;

-- Query for all locations that contain a phrase matching &#34;cen* par*&#34;.
-- This can match &#34;central park&#34;, &#34;century parade&#34;, &#34;census part&#34;, etc.
SELECT * FROM locations WHERE locations MATCH &#39;&#34;cen* par*&#34;&#39;;
</code></pre><p><em>How the Queries Work:</em></p>
<p>MATCH &lsquo;&ldquo;central park&rdquo;&rsquo; returns only the loactions with the exact phrase &ldquo;central park&rdquo;.
MATCH &lsquo;&ldquo;cen* par*&rdquo;&rsquo; returns any lcoations where words starting with &ldquo;cen&rdquo; are immediately followed by words starting with &ldquo;par&rdquo;, such as:</p>
<p><em>&ldquo;Central Park&rdquo;, &ldquo;Century Parade&rdquo;, &ldquo;Census Part&rdquo;</em></p>
<p>For more refer here: <a href="https://www.sqlite.org/fts3.html#full_text_index_queries">https://www.sqlite.org/fts3.html#full_text_index_queries</a></p>
<p><strong>Why to use this? Why can&rsquo;t just use the LIKE operator in query?</strong></p>
<p>Answer: Wait for the 2 part.</p>
<p>Happy coding.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://premkumar4701.github.io/">Prem Kumar J</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
